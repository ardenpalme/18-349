<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.11"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>349 RTOS: kernel/src/syscall_thread.c File Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">349 RTOS </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part --><!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">syscall_thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Function definitions of threading syscalls for creating, scheduling, killing threads, etc..  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;nvic.h&gt;</code><br />
<code>#include &lt;arm.h&gt;</code><br />
<code>#include &lt;printk.h&gt;</code><br />
<code>#include &lt;timer.h&gt;</code><br />
<code>#include &quot;syscall_thread.h&quot;</code><br />
<code>#include &quot;syscall_mutex.h&quot;</code><br />
<code>#include &quot;mpu.h&quot;</code><br />
<code>#include &quot;syscall.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinterrupt__stack__frame.html">interrupt_stack_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack frame upon exception.  <a href="structinterrupt__stack__frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcallee__stack__frame.html">callee_stack_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calle context saved stack frame.  <a href="structcallee__stack__frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtcb__t.html">tcb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread-specific kernel datat structures for thread management  <a href="structtcb__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgcb__t.html">gcb_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">global kernel data structures for thread management  <a href="structgcb__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c88edc8d48ce7172e288f14dd6a06d6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c88edc8d48ce7172e288f14dd6a06d6">XPSR_INIT</a>&#160;&#160;&#160;0x1000000</td></tr>
<tr class="memdesc:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial XPSR value, all 0s except thumb bit. <br /></td></tr>
<tr class="separator:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371aab84fd38885b868c73536fb52f53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a371aab84fd38885b868c73536fb52f53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a371aab84fd38885b868c73536fb52f53">MAIN_THREAD_IDX</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a371aab84fd38885b868c73536fb52f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of main thread <br /></td></tr>
<tr class="separator:a371aab84fd38885b868c73536fb52f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedbf0705711be771495895eb1bf7a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abedbf0705711be771495895eb1bf7a2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abedbf0705711be771495895eb1bf7a2a">IDLE_THREAD_IDX</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:abedbf0705711be771495895eb1bf7a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of idle thread <br /></td></tr>
<tr class="separator:abedbf0705711be771495895eb1bf7a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e42e87f6e71df32a7e1cd3e5c02a84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18e42e87f6e71df32a7e1cd3e5c02a84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a18e42e87f6e71df32a7e1cd3e5c02a84">USER_THREAD_FIRST_IDX</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a18e42e87f6e71df32a7e1cd3e5c02a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">index of the first user thread <br /></td></tr>
<tr class="separator:a18e42e87f6e71df32a7e1cd3e5c02a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaacdecd2278fcfdca3df92973ae74ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaacdecd2278fcfdca3df92973ae74ce6"></a>
<a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aaacdecd2278fcfdca3df92973ae74ce6">get_active_thread</a> ()</td></tr>
<tr class="memdesc:aaacdecd2278fcfdca3df92973ae74ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds currently executing thread <br /></td></tr>
<tr class="separator:aaacdecd2278fcfdca3df92973ae74ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c3ef28db7a2f48af4d17ac4b0b6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd7c3ef28db7a2f48af4d17ac4b0b6a3"></a>
<a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#afd7c3ef28db7a2f48af4d17ac4b0b6a3">get_next_thread</a> ()</td></tr>
<tr class="memdesc:afd7c3ef28db7a2f48af4d17ac4b0b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread scheduler <br /></td></tr>
<tr class="separator:afd7c3ef28db7a2f48af4d17ac4b0b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d9a6c97c477768c23b28d9439dbef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a800d9a6c97c477768c23b28d9439dbef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a800d9a6c97c477768c23b28d9439dbef">stack_overflows</a> (uint32_t max_threads, uint32_t stack_size)</td></tr>
<tr class="memdesc:a800d9a6c97c477768c23b28d9439dbef"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the available stack space is enough for thread stacks <br /></td></tr>
<tr class="separator:a800d9a6c97c477768c23b28d9439dbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3417ddf7da62fbaea7ca31e952e231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a3417ddf7da62fbaea7ca31e952e231"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a1a3417ddf7da62fbaea7ca31e952e231">setup_init_stack_frame</a> (<a class="el" href="structtcb__t.html">tcb_t</a> *thread, void *fn, void *vargp)</td></tr>
<tr class="memdesc:a1a3417ddf7da62fbaea7ca31e952e231"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper to setup new threads expected stack frame on pendSV interrupt <br /></td></tr>
<tr class="separator:a1a3417ddf7da62fbaea7ca31e952e231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c7ce18366b8100cfc5c940f168db64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a30c7ce18366b8100cfc5c940f168db64">set_default_threads</a> (void *idle_fn)</td></tr>
<tr class="memdesc:a30c7ce18366b8100cfc5c940f168db64"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes default and idle threads  <a href="#a30c7ce18366b8100cfc5c940f168db64">More...</a><br /></td></tr>
<tr class="separator:a30c7ce18366b8100cfc5c940f168db64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488042d659c12862f427f50ad0a1717"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7488042d659c12862f427f50ad0a1717"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7488042d659c12862f427f50ad0a1717">is_schedulable</a> (uint32_t newC, uint32_t newT)</td></tr>
<tr class="memdesc:a7488042d659c12862f427f50ad0a1717"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicates whether a task set is schedulable <br /></td></tr>
<tr class="separator:a7488042d659c12862f427f50ad0a1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a39cf5b93db92527d12eb618ed8408d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a39cf5b93db92527d12eb618ed8408d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7a39cf5b93db92527d12eb618ed8408d">update_thread_times</a> ()</td></tr>
<tr class="memdesc:a7a39cf5b93db92527d12eb618ed8408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates thread times as global clock changes <br /></td></tr>
<tr class="separator:a7a39cf5b93db92527d12eb618ed8408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a6d5fd88f960f074e01c0aa8f09b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a696a6d5fd88f960f074e01c0aa8f09b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a696a6d5fd88f960f074e01c0aa8f09b6">switch_mem_protect</a> (<a class="el" href="structtcb__t.html">tcb_t</a> *next_thread, <a class="el" href="structtcb__t.html">tcb_t</a> *last_thread)</td></tr>
<tr class="memdesc:a696a6d5fd88f960f074e01c0aa8f09b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">switches memory protectino between threads <br /></td></tr>
<tr class="separator:a696a6d5fd88f960f074e01c0aa8f09b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03d48542c5c84a2c9d297267e3553a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb03d48542c5c84a2c9d297267e3553a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aeb03d48542c5c84a2c9d297267e3553a">thread_kill</a> (void)</td></tr>
<tr class="memdesc:aeb03d48542c5c84a2c9d297267e3553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to assembly-defined global function for linker resolution. <br /></td></tr>
<tr class="separator:aeb03d48542c5c84a2c9d297267e3553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4419356f83c66940a90e846e6ec5ff98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a4419356f83c66940a90e846e6ec5ff98">find_inactive_thread</a> ()</td></tr>
<tr class="memdesc:a4419356f83c66940a90e846e6ec5ff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">find any one of the inactive threads  <a href="#a4419356f83c66940a90e846e6ec5ff98">More...</a><br /></td></tr>
<tr class="separator:a4419356f83c66940a90e846e6ec5ff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1014517bf7fbe33ac025d841dc46ac74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a1014517bf7fbe33ac025d841dc46ac74">set_pending_state</a> (kmutex_t *mutex, uint32_t thread_id, uint32_t val)</td></tr>
<tr class="memdesc:a1014517bf7fbe33ac025d841dc46ac74"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets thread is (not) pending to use mutex  <a href="#a1014517bf7fbe33ac025d841dc46ac74">More...</a><br /></td></tr>
<tr class="separator:a1014517bf7fbe33ac025d841dc46ac74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93b36b1229ad60897dbf240fe0cf09f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93b36b1229ad60897dbf240fe0cf09f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ae93b36b1229ad60897dbf240fe0cf09f">get_pending_state</a> (kmutex_t *mutex, uint32_t thread_id)</td></tr>
<tr class="memdesc:ae93b36b1229ad60897dbf240fe0cf09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">current state of whether thread is pending to use mutex <br /></td></tr>
<tr class="separator:ae93b36b1229ad60897dbf240fe0cf09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb898559509a392a236b7336e5ae6b77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#afb898559509a392a236b7336e5ae6b77">locked_geq_prio_mutex</a> (<a class="el" href="structtcb__t.html">tcb_t</a> *thread)</td></tr>
<tr class="memdesc:afb898559509a392a236b7336e5ae6b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether another mutex with a priorty &lt;= thread_prio is locked by a different thread  <a href="#afb898559509a392a236b7336e5ae6b77">More...</a><br /></td></tr>
<tr class="separator:afb898559509a392a236b7336e5ae6b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1d34f409d9db4fba714519c6e1ba67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7d1d34f409d9db4fba714519c6e1ba67">get_fallback_prio</a> (<a class="el" href="structtcb__t.html">tcb_t</a> *thread)</td></tr>
<tr class="memdesc:a7d1d34f409d9db4fba714519c6e1ba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns next highest dynamic priority after a thread has unlocked mutex  <a href="#a7d1d34f409d9db4fba714519c6e1ba67">More...</a><br /></td></tr>
<tr class="separator:a7d1d34f409d9db4fba714519c6e1ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62860f7d2ffe14fd900706b71434a3b3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a62860f7d2ffe14fd900706b71434a3b3">get_curr_prio</a> (uint32_t thread_id)</td></tr>
<tr class="memdesc:a62860f7d2ffe14fd900706b71434a3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current priority of a thread  <a href="#a62860f7d2ffe14fd900706b71434a3b3">More...</a><br /></td></tr>
<tr class="separator:a62860f7d2ffe14fd900706b71434a3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c86915231632ecc76da3e274c0880b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a19c86915231632ecc76da3e274c0880b">is_using_mutex</a> (uint32_t thread_id)</td></tr>
<tr class="memdesc:a19c86915231632ecc76da3e274c0880b"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if a thread is currently using a mutex  <a href="#a19c86915231632ecc76da3e274c0880b">More...</a><br /></td></tr>
<tr class="separator:a19c86915231632ecc76da3e274c0880b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc96a6564aa346ba124293a6604a0427"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc96a6564aa346ba124293a6604a0427"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abc96a6564aa346ba124293a6604a0427">systick_c_handler</a> ()</td></tr>
<tr class="memdesc:abc96a6564aa346ba124293a6604a0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">called when systick counter reaches 0, runs the scheduler, updates thread tick counts <br /></td></tr>
<tr class="separator:abc96a6564aa346ba124293a6604a0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8e4df25f8d82e54ed490334938875"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a41f8e4df25f8d82e54ed490334938875">pendsv_c_handler</a> (void *curr_msp)</td></tr>
<tr class="memdesc:a41f8e4df25f8d82e54ed490334938875"><td class="mdescLeft">&#160;</td><td class="mdescRight">contentext swaps between threads and runs the scheduler  <a href="#a41f8e4df25f8d82e54ed490334938875">More...</a><br /></td></tr>
<tr class="separator:a41f8e4df25f8d82e54ed490334938875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf395a32723974af129b9bf11689e8a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7cf395a32723974af129b9bf11689e8a">sys_thread_init</a> (uint32_t max_threads, uint32_t stack_size, void *idle_fn, protection_mode memory_protection, uint32_t max_mutexes)</td></tr>
<tr class="separator:a7cf395a32723974af129b9bf11689e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54104218aaaba481bd42968a6045691"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac54104218aaaba481bd42968a6045691">sys_thread_create</a> (void *fn, uint32_t prio, uint32_t C, uint32_t T, void *vargp)</td></tr>
<tr class="memdesc:ac54104218aaaba481bd42968a6045691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a memory protection region. Regions must be aligned!  <a href="#ac54104218aaaba481bd42968a6045691">More...</a><br /></td></tr>
<tr class="separator:ac54104218aaaba481bd42968a6045691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726d2166701a485c555e6b7f7af3b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">sys_scheduler_start</a> (uint32_t frequency)</td></tr>
<tr class="memdesc:a0726d2166701a485c555e6b7f7af3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall to get the running thread's current effective priority  <a href="#a0726d2166701a485c555e6b7f7af3b60">More...</a><br /></td></tr>
<tr class="separator:a0726d2166701a485c555e6b7f7af3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">sys_get_priority</a> ()</td></tr>
<tr class="memdesc:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall to get the running thread's current effective priority  <a href="#a8b4f86fe10ac2c90ce8158872aac7ce2">More...</a><br /></td></tr>
<tr class="separator:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341334c885696457b6f66bb8acda5b22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">sys_get_time</a> ()</td></tr>
<tr class="memdesc:a341334c885696457b6f66bb8acda5b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall to get the current time since the scheduler started  <a href="#a341334c885696457b6f66bb8acda5b22">More...</a><br /></td></tr>
<tr class="separator:a341334c885696457b6f66bb8acda5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8933e910725546aa9e052369db9cf81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">sys_thread_time</a> ()</td></tr>
<tr class="memdesc:aa8933e910725546aa9e052369db9cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall to get the current time since the thread initially ran in ticks  <a href="#aa8933e910725546aa9e052369db9cf81">More...</a><br /></td></tr>
<tr class="separator:aa8933e910725546aa9e052369db9cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e5d8e922ccdec535527e8d8724d78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a601e5d8e922ccdec535527e8d8724d78"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">sys_thread_kill</a> ()</td></tr>
<tr class="memdesc:a601e5d8e922ccdec535527e8d8724d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall to kill the currently thread <br /></td></tr>
<tr class="separator:a601e5d8e922ccdec535527e8d8724d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a3fb472158a93e59df836b9935b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a3a3fb472158a93e59df836b9935b54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">sys_wait_until_next_period</a> ()</td></tr>
<tr class="memdesc:a2a3a3fb472158a93e59df836b9935b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">waits until the next period of the system clock <br /></td></tr>
<tr class="separator:a2a3a3fb472158a93e59df836b9935b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3058e8c4464d614c9506562710e91"><td class="memItemLeft" align="right" valign="top">kmutex_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">sys_mutex_init</a> (uint32_t max_prio)</td></tr>
<tr class="memdesc:a12d3058e8c4464d614c9506562710e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize a mutex at a given priority ceiling  <a href="#a12d3058e8c4464d614c9506562710e91">More...</a><br /></td></tr>
<tr class="separator:a12d3058e8c4464d614c9506562710e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">sys_mutex_lock</a> (kmutex_t *mutex)</td></tr>
<tr class="memdesc:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">locks a resource, i.e a mutex  <a href="#a6a14ccbc1e43d61617b97ecd06cf65b9">More...</a><br /></td></tr>
<tr class="separator:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">sys_mutex_unlock</a> (kmutex_t *mutex)</td></tr>
<tr class="memdesc:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unlocks a resource, i.e a mutex  <a href="#a55db4294dd5ed35ee5b2b1b1043ddbdd">More...</a><br /></td></tr>
<tr class="separator:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe7fb0512c53514ac6dc96022034b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abfe7fb0512c53514ac6dc96022034b91">switch_mem_protect</a> (<a class="el" href="structtcb__t.html">tcb_t</a> *next_thread)</td></tr>
<tr class="memdesc:abfe7fb0512c53514ac6dc96022034b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">switches which memory region is protected  <a href="#abfe7fb0512c53514ac6dc96022034b91">More...</a><br /></td></tr>
<tr class="separator:abfe7fb0512c53514ac6dc96022034b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7979aa6eb5eea68979c8e94756419795"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7979aa6eb5eea68979c8e94756419795"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7979aa6eb5eea68979c8e94756419795">mem_fault</a> = 0</td></tr>
<tr class="memdesc:a7979aa6eb5eea68979c8e94756419795"><td class="mdescLeft">&#160;</td><td class="mdescRight">global for memory fault detection and handling <br /></td></tr>
<tr class="separator:a7979aa6eb5eea68979c8e94756419795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">ub_table</a> []</td></tr>
<tr class="memdesc:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precalculated values for UB test.  <a href="#a187e79dd2a6a18d6bbbc4f2509eb668b">More...</a><br /></td></tr>
<tr class="separator:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5304430cc4ea2a4a1014c9a723e10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgcb__t.html">gcb_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a07d5304430cc4ea2a4a1014c9a723e10">gcb</a></td></tr>
<tr class="separator:a07d5304430cc4ea2a4a1014c9a723e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a965b457902b75612d5c4db04d78cb6e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a965b457902b75612d5c4db04d78cb6e1"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a965b457902b75612d5c4db04d78cb6e1">__thread_u_stacks_low</a></td></tr>
<tr class="memdesc:a965b457902b75612d5c4db04d78cb6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a965b457902b75612d5c4db04d78cb6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7df5a7143f4fb8f52024cc2eb04d179e"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a7df5a7143f4fb8f52024cc2eb04d179e">__thread_u_stacks_top</a></td></tr>
<tr class="memdesc:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a7df5a7143f4fb8f52024cc2eb04d179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1e9fb5e74e0a3280d8d6b74d61146a"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aed1e9fb5e74e0a3280d8d6b74d61146a">__thread_k_stacks_low</a></td></tr>
<tr class="memdesc:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:aed1e9fb5e74e0a3280d8d6b74d61146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52f42f247ccf963d377b87cf4bc2ccca"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a52f42f247ccf963d377b87cf4bc2ccca">__thread_k_stacks_top</a></td></tr>
<tr class="memdesc:a52f42f247ccf963d377b87cf4bc2ccca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap high and low pointers. <br /></td></tr>
<tr class="separator:a52f42f247ccf963d377b87cf4bc2ccca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Function definitions of threading syscalls for creating, scheduling, killing threads, etc.. </p>
<dl class="section date"><dt>Date</dt><dd>4/29/21</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Arden Diakhate-Palme, Neville Chima </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4419356f83c66940a90e846e6ec5ff98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtcb__t.html">tcb_t</a> * find_inactive_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find any one of the inactive threads </p>
<p>gets an inactive thread which we can restart</p>
<dl class="section return"><dt>Returns</dt><dd>an inactive thread which we can restart </dd></dl>

</div>
</div>
<a class="anchor" id="a62860f7d2ffe14fd900706b71434a3b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_curr_prio </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current priority of a thread </p>
<p>get the curent priority of the passed thread</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>the passed thread TCB structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current priority of the thread </dd></dl>

</div>
</div>
<a class="anchor" id="a7d1d34f409d9db4fba714519c6e1ba67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_fallback_prio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns next highest dynamic priority after a thread has unlocked mutex </p>
<p>get the fallback priority of the passed thread in IPCP scheduling</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the passed thread TCB structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19c86915231632ecc76da3e274c0880b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t is_using_mutex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks if a thread is currently using a mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_id</td><td>the identifier of the thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb898559509a392a236b7336e5ae6b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int locked_geq_prio_mutex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether another mutex with a priorty &lt;= thread_prio is locked by a different thread </p>
<p>if the priority of the locked mutex is &gt;= get the higher mutex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the passed thread TCB structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the higher priority locked mutex </dd></dl>

</div>
</div>
<a class="anchor" id="a41f8e4df25f8d82e54ed490334938875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pendsv_c_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>curr_msp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>contentext swaps between threads and runs the scheduler </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr_msp</td><td>the current main stack pointer, which is passed in the asm handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30c7ce18366b8100cfc5c940f168db64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_default_threads </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes default and idle threads </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idle_fn</td><td>pointer to the idle function, or NULL if none provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1014517bf7fbe33ac025d841dc46ac74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_pending_state </td>
          <td>(</td>
          <td class="paramtype">kmutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets thread is (not) pending to use mutex </p>
<p>set mutex pending state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>passed kernel mutex </td></tr>
    <tr><td class="paramname">thread_id</td><td>the passed thread tcb structure </td></tr>
    <tr><td class="paramname">val</td><td>the value od the mutex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the higher priority locked mutex </dd></dl>

</div>
</div>
<a class="anchor" id="abfe7fb0512c53514ac6dc96022034b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void switch_mem_protect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtcb__t.html">tcb_t</a> *&#160;</td>
          <td class="paramname"><em>next_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>switches which memory region is protected </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_thread</td><td>the next scheduled thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b4f86fe10ac2c90ce8158872aac7ce2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>syscall to get the running thread's current effective priority </p>
<dl class="section return"><dt>Returns</dt><dd>the running thread's priority </dd></dl>

</div>
</div>
<a class="anchor" id="a341334c885696457b6f66bb8acda5b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>syscall to get the current time since the scheduler started </p>
<dl class="section return"><dt>Returns</dt><dd>the time passed since the scheduler started (unit of ticks) </dd></dl>

</div>
</div>
<a class="anchor" id="a12d3058e8c4464d614c9506562710e91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kmutex_t* sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize a mutex at a given priority ceiling </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_prio</td><td>max priority at which to init the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mutex structure of the just init'd mutex </dd></dl>

</div>
</div>
<a class="anchor" id="a6a14ccbc1e43d61617b97ecd06cf65b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">kmutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locks a resource, i.e a mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55db4294dd5ed35ee5b2b1b1043ddbdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">kmutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unlocks a resource, i.e a mutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to unlock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0726d2166701a485c555e6b7f7af3b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_scheduler_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>syscall to get the running thread's current effective priority </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>the frequency in Hz with which the scheduler should be run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="ac54104218aaaba481bd42968a6045691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables a memory protection region. Regions must be aligned! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>pointer to the thread function </td></tr>
    <tr><td class="paramname">prio</td><td>the thread's priority </td></tr>
    <tr><td class="paramname">C</td><td>the thread's worst-case runtime complexity in ticks </td></tr>
    <tr><td class="paramname">T</td><td>the thread's period </td></tr>
    <tr><td class="paramname">vargp</td><td>pointer to the arguments with which the thread function should be run 0 otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf395a32723974af129b9bf11689e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">protection_mode&#160;</td>
          <td class="paramname"><em>memory_protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_mutexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set all threads to inactive, and set IDs </p>

</div>
</div>
<a class="anchor" id="aa8933e910725546aa9e052369db9cf81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>syscall to get the current time since the thread initially ran in ticks </p>
<dl class="section return"><dt>Returns</dt><dd>the time since the thread initially ran </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a07d5304430cc4ea2a4a1014c9a723e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgcb__t.html">gcb_t</a> gcb</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intialize shared kernel data structure globally </p>

</div>
</div>
<a class="anchor" id="a187e79dd2a6a18d6bbbc4f2509eb668b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ub_table[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div><div class="line">  0.000, 1.000, .8284, .7798, .7568,</div><div class="line">  .7435, .7348, .7286, .7241, .7205,</div><div class="line">  .7177, .7155, .7136, .7119, .7106,</div><div class="line">  .7094, .7083, .7075, .7066, .7059,</div><div class="line">  .7052, .7047, .7042, .7037, .7033,</div><div class="line">  .7028, .7025, .7021, .7018, .7015,</div><div class="line">  .7012, .7009</div><div class="line">}</div></div><!-- fragment -->
<p>Precalculated values for UB test. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
</body>
</html>
